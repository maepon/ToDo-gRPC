package main

import (
	"connectrpc.com/connect"
	"context"
	todov1 "example.com/todo/gen/todo/v1" // generated by protoc-gen-go
	"example.com/todo/gen/todo/v1/todov1connect"
	"fmt"
	"github.com/google/uuid"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"
	"log"
	"net/http"
	"sync"
)

type ToDoServer struct{}

var m = sync.Map{}

func (s *ToDoServer) Read(
	ctx context.Context,
	req *connect.Request[todov1.ReadRequest],
) (*connect.Response[todov1.ReadResponse], error) {
	_, ok := m.Load(req.Msg.Id)
	if ok {
		fmt.Print(m.Load(req.Msg.Id))
		todo := &todov1.ToDo{
			Id:     req.Msg.Id,
			Name:   "aaa",
			Status: "aaaa",
		}

		res := connect.NewResponse(&todov1.ReadResponse{
				Todo: todo,
		})
		return res, nil
	}

	// m.Store(id, todo)
	// log.Println("Request headers: ", req.Header())
	// res := connect.NewResponse(&todov1.CreateResponse{
	// 	Todo: todo,
	// })
	// res.Header().Set("Greet-Version", "v1")
	todo_notfound := &todov1.ToDo{
		Id:     "notfound",
		Name:   "notfound",
		Status: "notfound",
	}
	not_found_res := connect.NewResponse(&todov1.ReadResponse{
		Todo: todo_notfound,
	})
	return not_found_res, nil
}

func (s *ToDoServer) Create(
	ctx context.Context,
	req *connect.Request[todov1.CreateRequest],
) (*connect.Response[todov1.CreateResponse], error) {
	fmt.Printf("%v", req)
	id := uuid.NewString()
	todo := &todov1.ToDo{
		Id:     id,
		Name:   req.Msg.Name,
		Status: req.Msg.Status,
	}
	m.Store(id, todo)
	log.Println("Request headers: ", req.Header())
	res := connect.NewResponse(&todov1.CreateResponse{
		Todo: todo,
	})
	res.Header().Set("Greet-Version", "v1")
	return res, nil
}

func (s *ToDoServer) Update(
	ctx context.Context,
	req *connect.Request[todov1.UpdateRequest],
) (*connect.Response[todov1.UpdateResponse], error) {
	log.Println("Request headers: ", req.Header())
	_, ok := m.Load(req.Msg.Id)
	if ok {
		todo := &todov1.ToDo{
			Id:     req.Msg.Id,
			Name:   req.Msg.Name,
			Status: req.Msg.Status,
		}

		m.Store(req.Msg.Id, todo)
		fmt.Print(m.Load(req.Msg.Id))
		res := connect.NewResponse(&todov1.UpdateResponse{
			Todo: todo,
		})
		res.Header().Set("Greet-Version", "v1")
		return res, nil
	}

	// TODO: Error handling
	todo_notfound := &todov1.ToDo{
		Id:     "notfound",
		Name:   "notfound",
		Status: "notfound",
	}
	not_found_res := connect.NewResponse(&todov1.UpdateResponse{
		Todo: todo_notfound,
	})
	return not_found_res, nil
}

func (s *ToDoServer) Delete(
	ctx context.Context,
	req *connect.Request[todov1.DeleteRequest],
) (*connect.Response[todov1.DeleteResponse], error) {
	log.Println("Request headers: ", req.Header())
	_, ok := m.Load(req.Msg.Id)
	if ok {
		m.Delete(req.Msg.Id)
		fmt.Println("m.load")
		fmt.Print(m.Load(req.Msg.Id))
		res := connect.NewResponse(&todov1.DeleteResponse{})
		res.Header().Set("Greet-Version", "v1")
		return res, nil
	}

	// TODO: Error handling
	not_found_res := connect.NewResponse(&todov1.DeleteResponse{})
	return not_found_res, nil
}

func main() {
	greeter := &ToDoServer{}
	mux := http.NewServeMux()
	path, handler := todov1connect.NewToDoServiceHandler(greeter)
	mux.Handle(path, handler)
	http.ListenAndServe(
		"localhost:8080",
		// Use h2c so we can serve HTTP/2 without TLS.
		h2c.NewHandler(mux, &http2.Server{}),
	)
}
